<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ANALYZER - Build 8.8 (Safe Reset Protocol) [RECOVERY BUILD]</title>
    <style>
        :root {
            --color-background-primary: #08080A; --color-element-primary: #141414; --color-funckey-primary: #2A2A2A;
            --color-text-passive: #B0B4C0; --color-text-active: #FFFFFF; --color-accent-primary: #00FFFF;
            --color-accent-bios: #00FF8A; --color-accent-error: #FF414B; --font-family: 'Consolas', 'Menlo', 'Courier New', monospace;
            --transition-speed: 220ms;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; width: 100%; overflow: hidden; background-color: var(--color-background-primary); color: var(--color-text-passive); font-family: var(--font-family); transition: background-color var(--transition-speed), color var(--transition-speed); }
        body { display: flex; justify-content: center; align-items: center; }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%); background-size: 100% 4px; z-index: 1000; }
        .window { display: none; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%; padding: 2vw; animation: fadeIn 0.5s ease-in-out; }
        .window.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes blink { 50% { opacity: 0; } }
        
        button { background: none; border: none; color: inherit; font-family: inherit; font-size: inherit; cursor: pointer; padding: 0; }
        button:focus-visible, .key:focus-visible, .level-button:focus-visible, .shop-item:focus-visible, .dpad-btn:focus-visible { outline: 3px solid var(--color-accent-bios); outline-offset: 2px; }

        .big-button { background-color: transparent; border: 2px solid var(--color-accent-primary); color: var(--color-accent-primary); padding: 15px 30px; font-size: 1.5em; text-transform: uppercase; transition: background-color var(--transition-speed), color var(--transition-speed); }
        .big-button:hover { background-color: var(--color-accent-primary); color: var(--color-background-primary); }
        .big-button.disabled { pointer-events: none; opacity: 0.4; border-color: var(--color-funckey-primary); color: var(--color-funckey-primary); }

        .container { display: flex; flex-direction: column; gap: 1rem; width: 100%; max-width: 1000px; text-align: center; }
        .centered-content { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%; gap: 1.5rem; }

        #preload .bios-text { width: 100%; max-width: 600px; color: var(--color-accent-bios); }
        #preload .bios-text span { animation: blink 1s step-end infinite; }
        #title h1 { color: var(--color-accent-primary); text-shadow: 0 0 10px var(--color-accent-primary); font-size: clamp(2em, 8vw, 5em); }
        
        #profile-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; padding: 1rem; max-height: 60vh; overflow-y: auto; width: 100%; }
        .profile-card { position: relative; border: 2px solid var(--color-funckey-primary); padding: 2rem 1rem; text-transform: uppercase; font-size: 1.5em; transition: all var(--transition-speed); }
        .profile-card:hover { border-color: var(--color-accent-primary); color: var(--color-accent-primary); }
        .delete-profile-btn { position: absolute; top: 5px; right: 5px; width: 30px; height: 30px; font-size: 20px; color: var(--color-text-passive); }
        .delete-profile-btn:hover { color: var(--color-accent-error); }
        
        .mode-button { font-size: 2.5em; padding: 3rem 2rem; width: 100%; max-width: 400px; }

        #player-name-output { border: 2px solid var(--color-accent-primary); background-color: var(--color-element-primary); color: var(--color-text-active); padding: 15px 25px; font-size: clamp(1.5em, 4vw, 2.5em); min-height: 80px; width: 100%; max-width: 800px; text-align: center; letter-spacing: 0.1em; text-transform: uppercase; flex-shrink: 0; margin-bottom: 1rem; }
        #player-name-output::after { content: '_'; animation: blink 1s step-end infinite; }
        
        #keyboard-wrapper { flex-grow: 1; display: flex; justify-content: center; align-items: center; width: 100%; }
        #virtualKeyboard { display: grid; gap: var(--gap); grid-template-columns: repeat(8, var(--k)); grid-auto-rows: var(--k); }
        .key { position: relative; display: flex; justify-content: center; align-items: center; background-color: var(--color-element-primary); border: 1px solid var(--color-funckey-primary); color: var(--color-text-passive); font-size: calc(var(--k) * 0.4); user-select: none; transition: background-color 100ms, color 100ms; }
        .key:active { background-color: var(--color-accent-primary); color: var(--color-background-primary); }
        .key.span2 { grid-column: span 2; }
        .key.funckey { background-color: var(--color-funckey-primary); color: var(--color-accent-primary); }
        .key.active { background-color: var(--color-accent-primary); color: var(--color-background-primary); }
        
        #mainMenu-header { border-bottom: 2px solid var(--color-funckey-primary); padding-bottom: 1rem; margin-bottom: 1rem; width: 100%; }
        #mainMenu-header h2 { font-size: 2em; color: var(--color-text-active); }
        #mainMenu-player-name, #mainMenu-total-points { color: var(--color-accent-primary); font-weight: bold; }
        .mainMenu-buttons { display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; margin-top: 1rem; }
        #level-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 1rem; padding: 1rem; width:100%; }
        .level-button { position: relative; display: flex; justify-content: center; align-items: center; aspect-ratio: 1 / 1; border: 2px solid var(--color-funckey-primary); background-color: var(--color-element-primary); color: var(--color-text-passive); font-size: 2.5em; transition: all var(--transition-speed); }
        .level-button .highscore { display: none; position: absolute; bottom: 5px; left: 0; right: 0; font-size: 0.3em; color: var(--color-accent-bios); }
        .level-button:hover .highscore { display: block; }
        .level-button:not(.completed):hover { border-color: var(--color-accent-primary); color: var(--color-accent-primary); text-shadow: 0 0 10px var(--color-accent-primary); }
        .level-button.completed { border-color: var(--color-funckey-primary); background-color: transparent; opacity: 0.6; pointer-events: none; }
        .level-button.completed .lock-icon { width: 40%; height: 40%; fill: var(--color-funckey-primary); }

        .page-header { width: 100%; text-align: center; border-bottom: 2px solid var(--color-funckey-primary); padding-bottom: 1rem; }
        #shop-items-container { width: 100%; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; padding: 1rem; max-height: 70vh; overflow-y: auto; }
        .shop-item { display: flex; flex-direction: column; text-align: left; padding: 1rem; border: 2px solid var(--color-funckey-primary); transition: all var(--transition-speed); }
        .shop-item:hover { border-color: var(--color-accent-bios); }
        .shop-item h3 { color: var(--color-accent-bios); }
        .shop-item-details { flex-grow: 1; }
        .shop-item-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; }
        .shop-item-cost { font-size: 1.5em; color: var(--color-accent-primary); }
        
        #stats-display { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; padding: 1rem; width: 100%; }
        .stat-card { background-color: var(--color-element-primary); padding: 1rem; }
        .stat-card .value { font-size: 2em; color: var(--color-accent-primary); }
        #achievements-grid { width: 100%; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; padding: 1rem; max-height: 50vh; overflow-y: auto; }
        .achievement-card { padding: 1rem; border: 2px solid var(--color-funckey-primary); text-align: left; }
        .achievement-card.unlocked { border-color: var(--color-accent-bios); }
        .achievement-card h3 { color: var(--color-accent-bios); }
        .achievement-card.locked h3 { color: var(--color-funckey-primary); }
        .achievement-card.locked p { opacity: 0.5; }

        #game { justify-content: flex-start; padding: 0; position: relative; }
        #game-hud { font-size: 1.2em; color: var(--color-text-active); flex-shrink: 0; padding: 10px; width: 100%; display: flex; justify-content: space-between; align-items: center; height: 50px; z-index: 10; }
        #hud-target .collected { opacity: 0.4; }
        #hud-target .bypass-flash { color: var(--color-accent-bios); text-shadow: 0 0 10px var(--color-accent-bios); }
        
        #game-inventory { display: flex; gap: 1rem; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; }
        .inventory-item { display: flex; align-items: center; gap: 0.5rem; }
        .inventory-item .key-hint { padding: 2px 5px; border: 1px solid var(--color-text-passive); border-radius: 3px; font-size: 0.8em; }

        #game-canvas-wrapper { width: 100%; flex-grow: 1; display: flex; justify-content: center; align-items: center; }
        #game-canvas { background-color: #0a0a0a; border: 2px solid var(--color-funckey-primary); box-shadow: 0 0 10px var(--color-funckey-primary); }
        body.is-shaking #game-canvas { animation: shake 0.3s linear; }
        @keyframes shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-4px, 4px); } 50% { transform: translate(4px, -4px); } 75% { transform: translate(-4px, 4px); } }

        #dpad-container {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 180px;
            height: 180px;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 2px;
            background-color: rgba(10, 10, 10, 0.7);
            padding: 10px;
            border-radius: 10px;
            z-index: 10;
        }
        #dpad-container.visible {
            display: grid;
        }
        #dpad-drag-handle {
            grid-area: 2 / 2 / 3 / 3;
            cursor: move;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px dashed var(--color-funckey-primary);
        }
        .dpad-btn {
            background-color: var(--color-element-primary);
            border: 1px solid var(--color-funckey-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 100ms;
            user-select: none;
        }
        .dpad-btn svg {
            width: 60%;
            height: 60%;
            fill: var(--color-text-passive);
            transition: fill 100ms;
            pointer-events: none;
        }
        .dpad-btn:active {
            background-color: var(--color-accent-primary);
            transform: scale(0.95);
        }
        .dpad-btn:active svg {
            fill: var(--color-background-primary);
        }
        #dpad-up { grid-area: 1 / 2 / 2 / 3; }
        #dpad-left { grid-area: 2 / 1 / 3 / 2; }
        #dpad-down { grid-area: 3 / 2 / 4 / 3; }
        #dpad-right { grid-area: 2 / 3 / 3 / 4; }

        #validation-output { border: 2px solid var(--color-accent-primary); background-color: var(--color-element-primary); color: var(--color-text-active); padding: 15px 25px; font-size: clamp(1.5em, 4vw, 2.5em); min-height: 80px; width: 100%; max-width: 800px; text-align: center; letter-spacing: 0.1em; text-transform: uppercase; flex-shrink: 0; }
        #validation-output.error { animation: shake 0.3s linear; }
        #validation-keyboard-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 2rem; }
        .validation-key { width: 70px; height: 70px; background-color: var(--color-element-primary); border: 1px solid var(--color-funckey-primary); font-size: 2.5em; }
        .validation-key:active { background-color: var(--color-accent-primary); color: var(--color-background-primary); }
        .validation-key.funckey { background-color: var(--color-funckey-primary); color: var(--color-accent-primary); }
        
        #victory h2 { font-size: 3em; color: var(--color-accent-bios); margin-bottom: 2rem; }

        #settings-button { display: none; position: fixed; top: 20px; right: 20px; width: 50px; height: 50px; background-color: var(--color-element-primary); border: 1px solid var(--color-funckey-primary); color: var(--color-text-passive); font-size: 28px; justify-content: center; align-items: center; cursor: pointer; z-index: 1001; transition: color var(--transition-speed); user-select: none; }
        #settings-button:hover { color: var(--color-accent-primary); }
        #settings-panel { display: none; position: fixed; top: 80px; right: 20px; background-color: var(--color-element-primary); border: 1px solid var(--color-funckey-primary); z-index: 1001; padding: 10px; }
        #settings-panel button { display: block; width: 100%; text-align: left; background-color: var(--color-funckey-primary); color: var(--color-text-passive); border: 1px solid var(--color-text-passive); padding: 10px 20px; margin-top: 10px; cursor: pointer; font-family: var(--font-family); font-size: 1em; }
        #settings-panel button:first-child { margin-top: 0; }
        #settings-panel button:hover { border-color: var(--color-accent-primary); color: var(--color-accent-primary); }

        #fullscreen-enforcer {
            z-index: 2000;
            background-color: rgba(8, 8, 10, 0.9);
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <div id="preload" class="window active">
        <div class="container centered-content">
            <div class="bios-text">
                <p>ANALYZER BIOS v1.8 (c) McLaure</p>
                <p>Initializing KERNEL...</p>
                <p>Memory Check: 65536K OK</p>
                <p>Loading UI assets... DONE</p>
                <p id="preflight-status">Running preflight checks...<span>_</span></p>
            </div>
        </div>
    </div>
    <div id="title" class="window">
        <div class="container centered-content">
            <h1>ANALYZER INTERFACE</h1>
            <button id="start-btn" class="big-button">INICIAR Y ENTRAR A PANTALLA COMPLETA</button>
        </div>
    </div>
    
    <div id="profiles" class="window">
        <div class="container centered-content">
            <h2>SELECCIONA TU PERFIL DE OPERADOR</h2>
            <div id="profile-grid"></div>
            <button id="new-player-btn" class="big-button">NUEVO OPERADOR</button>
        </div>
    </div>
    
    <div id="modeSelect" class="window">
        <div class="container centered-content">
            <h2>SELECCIONA MODO DE JUEGO</h2>
            <button class="big-button mode-button" data-mode="MAZE">MODO LABERINTO</button>
            <button class="big-button mode-button" data-mode="OPEN_FIELD">MODO CAMPO ABIERTO</button>
        </div>
    </div>

    <div id="player" class="window"><div class="container centered-content"><h2>INGRESA TU NOMBRE DE OPERADOR</h2><div id="player-name-output"></div><div id="keyboard-wrapper"><div id="virtualKeyboard"></div></div></div></div>
    <div id="mainMenu" class="window">
        <div class="container centered-content">
            <div id="mainMenu-header">
                <h2 id="mainMenu-title">MENU DE NIVELES</h2>
                <p>OPERADOR: <span id="mainMenu-player-name"></span> | PUNTOS: <span id="mainMenu-total-points">0</span></p>
            </div>
            <div id="level-grid"></div>
            <div class="mainMenu-buttons">
                <button id="stats-btn" class="big-button">ESTADISTICAS</button>
                <button id="terminal-btn" class="big-button">TERMINAL</button>
                <button id="change-mode-btn" class="big-button">CAMBIAR MODO</button>
            </div>
        </div>
    </div>
    <div id="terminal" class="window">
        <div class="container centered-content">
            <div class="page-header">
                <h2>TERMINAL DE MEJORAS</h2>
                <p>PUNTOS DISPONIBLES: <span id="terminal-total-points">0</span></p>
            </div>
            <div id="shop-items-container"></div>
            <button id="back-to-menu-btn" class="big-button">VOLVER AL MENU</button>
        </div>
    </div>
    <div id="stats" class="window">
        <div class="container centered-content">
            <div class="page-header"><h2>REGISTRO DEL OPERADOR</h2></div>
            <div id="stats-display"></div>
            <h3>LOGROS DESBLOQUEADOS</h3>
            <div id="achievements-grid"></div>
            <button id="stats-back-btn" class="big-button">VOLVER AL MENU</button>
        </div>
    </div>
    <div id="game" class="window">
        <div id="game-hud">
            <span id="hud-target"></span>
            <div id="game-inventory"></div>
            <div class="hud-right-panel">
                 <div class="score-display">
                    <span id="hud-score"></span> | <span id="hud-total-points"></span>
                </div>
            </div>
        </div>
        <div id="game-canvas-wrapper"><canvas id="game-canvas"></canvas></div>
        <div id="dpad-container">
            <div id="dpad-drag-handle"></div>
            <button class="dpad-btn" id="dpad-up" data-key="ArrowUp"><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg></button>
            <button class="dpad-btn" id="dpad-left" data-key="ArrowLeft"><svg viewBox="0 0 24 24"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z"/></svg></button>
            <button class="dpad-btn" id="dpad-down" data-key="ArrowDown"><svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg></button>
            <button class="dpad-btn" id="dpad-right" data-key="ArrowRight"><svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg></button>
        </div>
    </div>
    
    <div id="validation" class="window">
        <div class="container centered-content">
            <h2>RECONSTRUYE EL COMANDO</h2>
            <div id="validation-output"></div>
            <div id="validation-keyboard-container"></div>
            <div style="margin-top: 2rem; display: flex; gap: 1rem;">
                <button id="validate-word-btn" class="big-button">VALIDAR</button>
                <button id="hint-btn" class="big-button">PISTA (-250)</button>
            </div>
        </div>
    </div>
    
    <div id="victory" class="window">
        <div class="container centered-content">
            <h2>COMANDO EJECUTADO</h2>
            <button id="victory-continue-btn" class="big-button">CONTINUAR</button>
        </div>
    </div>

    <button id="settings-button">?</button>
    <div id="settings-panel">
        <button id="sound-btn">SONIDO: ON</button>
        <button id="palette-btn">PALETA</button>
        <button id="dpad-settings-btn">D-PAD: ON</button>
        <button id="change-player-btn">CAMBIAR JUGADOR</button>
        <button id="exit-btn">SALIR</button>
    </div>

    <div id="fullscreen-enforcer" class="window">
        <div class="container centered-content">
            <h2>PANTALLA COMPLETA REQUERIDA</h2>
            <p style="font-size: 1.2em; max-width: 600px;">ANALYZER está diseñado para una experiencia inmersiva. Por favor, reanuda el modo de pantalla completa para continuar.</p>
            <button id="resume-fullscreen-btn" class="big-button" style="margin-top: 2rem;">REANUDAR SESIÓN</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const WORD_BANK = {
                LEN_4: ["CODE", "DATA", "EXEC", "PING", "ROOT", "BASH", "BOOT", "LOAD"],
                LEN_5: ["INPUT", "QUERY", "FETCH", "SHELL", "ADMIN", "LOGIN", "TOKEN", "PROXY"],
                LEN_6: ["SIGNAL", "STREAM", "BUFFER", "KERNEL", "DAEMON", "DRIVER", "MODULE", "ACCESS"],
                LEN_7: ["POINTER", "PROCESS", "SYSCALL", "COMMAND", "NETWORK", "ROUTER", "SERVICE", "ACCOUNT"],
                LEN_8: ["FUNCTION", "VARIABLE", "REGISTER", "PROTOCOL", "FIREWALL", "SECURITY", "ENDPOINT", "INSTANCE"],
                LEN_9: ["HANDSHAKE", "EXCEPTION", "INTERRUPT", "ALGORITHM", "FRAMEWORK", "CONTAINER", "RECURSIVE"],
                LEN_11: ["AUTHENTICATE", "PERMISSION", "DECRYPTION", "COMPILATION", "OPTIMIZATION", "BACKTRACK"],
                LEN_12_PLUS: ["SYNCHRONIZE", "ACKNOWLEDGE", "MULTITHREAD", "VIRTUALIZATION", "SUPERCOMPUTER", "NON-EUCLIDEAN", "SINGULARITY"]
            };
            
            const LEVEL_CONFIG = {
                MAZE: [
                    { level: 1, commandCategory: 'LEN_4', gridSize: 50 },
                    { level: 2, commandCategory: 'LEN_5', gridSize: 45 },
                    { level: 3, commandCategory: 'LEN_5', gridSize: 45, enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.02 } }] },
                    { level: 4, commandCategory: 'LEN_6', gridSize: 40, enemies: [{ type: 'PATRULLA', count: 2, params: { speed: 0.03 } }] },
                    { level: 5, commandCategory: 'LEN_6', gridSize: 40, specialBlocks: [{ type: 'SLOW', count: 3 }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.03 } }] },
                    { level: 6, commandCategory: 'LEN_7', gridSize: 35, enemies: [{ type: 'RASTREADOR', count: 1, params: { speed: 800 } }] },
                    { level: 7, commandCategory: 'LEN_7', gridSize: 35, specialBlocks: [{ type: 'T-PORT', count: 2, id: 1, color: '#A43BFF' }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.04 } }] },
                    { level: 8, commandCategory: 'LEN_8', gridSize: 30, specialBlocks: [{ type: 'SLOW', count: 4 }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.05 } }, { type: 'RASTREADOR', count: 1, params: { speed: 750 } }] },
                    { level: 9, commandCategory: 'LEN_9', gridSize: 30, enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.05 } }, { type: 'RASTREADOR', count: 1, params: { speed: 700 } }] },
                    { level: 10, commandCategory: 'LEN_9', gridSize: 25, specialBlocks: [{ type: 'SOLID', count: 8 }], enemies: [{ type: 'RASTREADOR', count: 2, params: { speed: 700 } }] },
                    { level: 11, commandCategory: 'LEN_11', gridSize: 25, specialBlocks: [{ type: 'T-PORT', count: 2, id: 3, color: '#FFC700' }], enemies: [{ type: 'RASTREADOR', count: 1, params: { speed: 600 } }] },
                    { level: 12, commandCategory: 'LEN_12_PLUS', gridSize: 20, specialBlocks: [{ type: 'SLOW', count: 1 }, { type: 'SOLID', count: 1 }, { type: 'T-PORT', count: 2, id: 5, color: '#00FF8A' }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.08 } }, { type: 'RASTREADOR', count: 2, params: { speed: 650 } }] }
                ],
                OPEN_FIELD: [
                    { level: 1, commandCategory: 'LEN_4', gridSize: 60 },
                    { level: 2, commandCategory: 'LEN_5', gridSize: 55 },
                    { level: 3, commandCategory: 'LEN_6', gridSize: 55, specialBlocks: [{ type: 'SOLID', count: 4 }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.03 } }] },
                    { level: 4, commandCategory: 'LEN_7', gridSize: 50, specialBlocks: [{ type: 'SOLID', count: 5 }], enemies: [{ type: 'PATRULLA', count: 2, params: { speed: 0.04 } }] },
                    { level: 5, commandCategory: 'LEN_8', gridSize: 50, specialBlocks: [{ type: 'SLOW', count: 6 }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.05 } }] },
                    { level: 6, commandCategory: 'LEN_8', gridSize: 45, specialBlocks: [{ type: 'SOLID', count: 4 }], enemies: [{ type: 'RASTREADOR', count: 1, params: { speed: 700 } }] },
                    { level: 7, commandCategory: 'LEN_9', gridSize: 45, specialBlocks: [{ type: 'SOLID', count: 6 }], enemies: [{ type: 'RASTREADOR', count: 1, params: { speed: 650 } }] },
                    { level: 8, commandCategory: 'LEN_9', gridSize: 40, specialBlocks: [{ type: 'SOLID', count: 3 }, { type: 'SLOW', count: 3 }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.05 } }, { type: 'RASTREADOR', count: 1, params: { speed: 750 } }] },
                    { level: 9, commandCategory: 'LEN_11', gridSize: 40, specialBlocks: [{ type: 'T-PORT', count: 2, id: 1, color: '#A43BFF' }, { type: 'SOLID', count: 7 }], enemies: [{ type: 'RASTREADOR', count: 2, params: {speed: 625} }] },
                    { level: 10, commandCategory: 'LEN_11', gridSize: 35, specialBlocks: [{ type: 'SLOW', count: 5 }, { type: 'SOLID', count: 3 }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.06 } }, { type: 'RASTREADOR', count: 1, params: { speed: 600 } }] },
                    { level: 11, commandCategory: 'LEN_12_PLUS', gridSize: 35, specialBlocks: [{ type: 'T-PORT', count: 2, id: 3, color: '#FFC700' }, { type: 'SOLID', count: 3 }], enemies: [{ type: 'RASTREADOR', count: 2, params: { speed: 600 } }] },
                    { level: 12, commandCategory: 'LEN_12_PLUS', gridSize: 30, specialBlocks: [{ type: 'SLOW', count: 1 }, { type: 'SOLID', count: 1 }, { type: 'T-PORT', count: 2, id: 5, color: '#00FF8A' }], enemies: [{ type: 'PATRULLA', count: 1, params: { speed: 0.08 } }, { type: 'RASTREADOR', count: 2, params: { speed: 650 } }] }
                ]
            };

            const SHOP_ITEMS = {
                shield: { name: "ESCUDO DE ENERGIA", desc: "Absorbe una colision con una entidad hostil.", cost: 2500, keyHint: '1' },
                bypass: { name: "CHIP DE OMISION", desc: "Marca la siguiente letra requerida como 'recogida'.", cost: 4000, keyHint: '2' },
                speed: { name: "SOBRECARGA TEMPORAL", desc: "Aumenta la velocidad del operador por 5 segundos.", cost: 1500, keyHint: '3' }
            };
            const ACHIEVEMENT_DATA = {
                'NOVICE': { name: 'NOVATO', desc: 'Completa tu primer nivel.' },
                'MAZE_MASTER': { name: 'MAESTRO DEL LABERINTO', desc: 'Completa los 12 niveles del Modo Laberinto.' },
                'FIELD_EXPLORER': { name: 'EXPLORADOR DE CAMPO ABIERTO', desc: 'Completa los 12 niveles del Modo Campo Abierto.' },
                'UNTOUCHABLE': { name: 'INTOCABLE', desc: 'Completa un nivel con enemigos sin recibir daño.' },
                'TYCOON': { name: 'MAGNATE', desc: 'Acumula 100,000 puntos totales.' },
                'COLLECTOR': { name: 'COLECCIONISTA', desc: 'Compra al menos un item de cada tipo en el Terminal.' }
            };

            const PALETTES = { 'CODIGO_CIAN': { bg: '#08080A', text: '#B0B4C0', accent: '#00FFFF', error: '#FF1A4B' }, 'VOLCAN_FUEGO': { bg: '#100505', text: '#D6C2C2', accent: '#FF1A4B', error: '#E8FF3B' }, 'JUNGLA_SECRETA': { bg: '#051007', text: '#C2D6C7', accent: '#00FF41', error: '#FF6B00' }, 'GALAXIA_PURPURA': { bg: '#0C0510', text: '#CEC2D6', accent: '#A43BFF', error: '#3BFFF8' }, 'TESORO_DORADO': { bg: '#1A1405', text: '#E0D6C2', accent: '#FFC700', error: '#FF3B3B' }, 'OCEANO_PROFUNDO': { bg: '#050C1A', text: '#C2D0E0', accent: '#007BFF', error: '#FFA500' }, 'NEON_ELECTRICO': { bg: '#000010', text: '#B0B0FF', accent: '#39FF14', error: '#FF007F' }, 'AURORA_BOREAL': { bg: '#001018', text: '#CCEFFF', accent: '#00FFD5', error: '#FF00D5' }, };
            const PALETTE_ORDER = Object.keys(PALETTES);
            const state = { currentView: 'preload', operatorName: '', currentMode: null, isShiftActive: false, soundOn: true, currentPaletteIndex: 0, validationAttempt: '', dpadVisible: true, playerData: { totalPoints: 0, inventory: {}, stats: {}, achievements: {} } };
            const dom = {
                body: document.body,
                windows: { preload: document.getElementById('preload'), title: document.getElementById('title'), profiles: document.getElementById('profiles'), modeSelect: document.getElementById('modeSelect'), player: document.getElementById('player'), mainMenu: document.getElementById('mainMenu'), terminal: document.getElementById('terminal'), stats: document.getElementById('stats'), game: document.getElementById('game'), validation: document.getElementById('validation'), victory: document.getElementById('victory') },
                profileGrid: document.getElementById('profile-grid'),
                modeButtons: document.querySelectorAll('.mode-button'),
                playerNameOutput: document.getElementById('player-name-output'), virtualKeyboard: document.getElementById('virtualKeyboard'), keyboardWrapper: document.getElementById('keyboard-wrapper'),
                mainMenuPlayerName: document.getElementById('mainMenu-player-name'), mainMenuTotalPoints: document.getElementById('mainMenu-total-points'), mainMenuTitle: document.getElementById('mainMenu-title'), levelGrid: document.getElementById('level-grid'),
                terminalTotalPoints: document.getElementById('terminal-total-points'), shopItemsContainer: document.getElementById('shop-items-container'),
                statsDisplay: document.getElementById('stats-display'), achievementsGrid: document.getElementById('achievements-grid'),
                gameHud: { target: document.getElementById('hud-target'), score: document.getElementById('hud-score'), totalPoints: document.getElementById('hud-total-points'), inventory: document.getElementById('game-inventory') }, 
                gameCanvas: document.getElementById('game-canvas'), gameCanvasWrapper: document.getElementById('game-canvas-wrapper'),
                dpadContainer: document.getElementById('dpad-container'), dpadBtns: document.querySelectorAll('.dpad-btn'),
                settingsButton: document.getElementById('settings-button'), settingsPanel: document.getElementById('settings-panel'),
                soundBtn: document.getElementById('sound-btn'), paletteBtn: document.getElementById('palette-btn'),
                dpadSettingsBtn: document.getElementById('dpad-settings-btn'),
                changePlayerBtn: document.getElementById('change-player-btn'), changeModeBtn: document.getElementById('change-mode-btn'), exitBtn: document.getElementById('exit-btn'),
                validationOutput: document.getElementById('validation-output'),
                validationKeyboardContainer: document.getElementById('validation-keyboard-container'),
                fullscreenEnforcer: document.getElementById('fullscreen-enforcer'),
            };

            const storage = {
                loadProfiles: () => { try { const d = localStorage.getItem('analyzer:profiles'); return d ? JSON.parse(d) : []; } catch(e) { return []; } },
                saveProfiles: (profiles) => { try { localStorage.setItem('analyzer:profiles', JSON.stringify(profiles)); } catch(e) {} },
                saveProfile: (name) => { const profiles = storage.loadProfiles(); if (!profiles.includes(name)) { profiles.push(name); storage.saveProfiles(profiles); } },
                deleteProfile: (name) => { let profiles = storage.loadProfiles(); profiles = profiles.filter(p => p !== name); storage.saveProfiles(profiles); localStorage.removeItem(`analyzer:playerData:${name}`); ['MAZE', 'OPEN_FIELD'].forEach(mode => { for (let i=1; i<=12; i++) { localStorage.removeItem(`analyzer:level_done:${mode}:${i}:${name}`); localStorage.removeItem(`analyzer:highscore:${mode}:${i}:${name}`); } }); },
                loadPlayerData: (name) => { 
                    try { 
                        const d = localStorage.getItem(`analyzer:playerData:${name}`); 
                        const data = d ? JSON.parse(d) : { totalPoints: 0, inventory: {}, stats: {}, achievements: {} }; 
                        if (!data.inventory) data.inventory = {};
                        if (!data.stats) data.stats = { timePlayed: 0, levelsCompleted_MAZE: 0, levelsCompleted_OPEN_FIELD: 0 };
                        if (!data.achievements) data.achievements = {};
                        return data; 
                    } catch(e) { return { totalPoints: 0, inventory: {}, stats: {}, achievements: {} }; } 
                },
                savePlayerData: (name, data) => { try { localStorage.setItem(`analyzer:playerData:${name}`, JSON.stringify(data)); } catch(e) {} },
                markLevelAsDone: (mode, level, name) => { try { localStorage.setItem(`analyzer:level_done:${mode}:${level}:${name}`, '1'); } catch(e) {} },
                isLevelDone: (mode, level, name) => { try { return localStorage.getItem(`analyzer:level_done:${mode}:${level}:${name}`) === '1'; } catch(e) { return false; } },
                getHighscore: (mode, level, name) => { try { return parseInt(localStorage.getItem(`analyzer:highscore:${mode}:${level}:${name}`), 10) || 0; } catch(e) { return 0; } },
                setHighscore: (mode, level, name, score) => { try { const current = storage.getHighscore(mode, level, name); if (score > current) { localStorage.setItem(`analyzer:highscore:${mode}:${level}:${name}`, score); } } catch(e) {} },
                saveSoundPref: (isOn) => { try { localStorage.setItem('analyzer:soundOn', isOn ? '1' : '0'); } catch(e) {} },
                loadSoundPref: () => { try { return localStorage.getItem('analyzer:soundOn') !== '0'; } catch(e) { return true; } },
                savePalette: (name) => { try { localStorage.setItem('analyzer:palette', name); } catch(e) {} },
                loadPalette: () => { try { return localStorage.getItem('analyzer:palette') || 'CODIGO_CIAN'; } catch(e) { return 'CODIGO_CIAN'; } },
                saveDpadPref: (isVisible) => { try { localStorage.setItem('analyzer:dpadVisible', isVisible ? '1' : '0'); } catch(e) {} },
                loadDpadPref: () => {
                    try {
                        const pref = localStorage.getItem('analyzer:dpadVisible');
                        if (pref === null) return false; // Default to OFF on first run
                        return pref === '1';
                    } catch (e) {
                        return false; // Default to OFF on error
                    }
                },
            };

            const statsManager = {
                unlock: function(achievementId) {
                    if (!state.playerData.achievements[achievementId]) {
                        state.playerData.achievements[achievementId] = true;
                    }
                },
                checkAchievements: function() {
                    const { stats, achievements, inventory, totalPoints } = state.playerData;
                    if (!achievements['NOVICE'] && ((stats.levelsCompleted_MAZE || 0) > 0 || (stats.levelsCompleted_OPEN_FIELD || 0) > 0)) {
                        this.unlock('NOVICE');
                    }
                    if (!achievements['MAZE_MASTER'] && (stats.levelsCompleted_MAZE || 0) >= 12) {
                        this.unlock('MAZE_MASTER');
                    }
                    if (!achievements['FIELD_EXPLORER'] && (stats.levelsCompleted_OPEN_FIELD || 0) >= 12) {
                        this.unlock('FIELD_EXPLORER');
                    }
                    if (!achievements['TYCOON'] && totalPoints >= 100000) {
                        this.unlock('TYCOON');
                    }
                    if (!achievements['COLLECTOR']) {
                        if ((inventory.shield || 0) > 0 && (inventory.bypass || 0) > 0 && (inventory.speed || 0) > 0) {
                            this.unlock('COLLECTOR');
                        }
                    }
                },
                logEvent: function(eventName, data = {}) {
                    const { stats } = state.playerData;
                    
                    if (eventName === 'GAME_TICK' && data.time) {
                        stats.timePlayed = (stats.timePlayed || 0) + data.time;
                    }

                    if (eventName === 'LEVEL_COMPLETE') {
                        const key = `levelsCompleted_${data.mode}`;
                        stats[key] = (stats[key] || 0) + 1;
                        if(data.isUntouchable) {
                            this.unlock('UNTOUCHABLE');
                        }
                    }
                    
                    this.checkAchievements();
                    storage.savePlayerData(state.operatorName, state.playerData);
                }
            };

            const audioManager = {
                ctx: null, isInitialized: false, masterGain: null,
                init: function() { if(this.isInitialized) return; try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = 0.3; this.masterGain.connect(this.ctx.destination); this.isInitialized = true; } catch(e) { console.error("Web Audio API not supported."); } },
                playSound: function(type) { if (!this.isInitialized || !state.soundOn) return; const now = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterGain); switch(type) { case 'move': o.type = 'sine'; o.frequency.setValueAtTime(800, now); g.gain.setValueAtTime(0.3, now); o.frequency.exponentialRampToValueAtTime(1200, now + 0.05); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.05); break; case 'collect': o.type = 'sine'; o.frequency.setValueAtTime(440, now); o.frequency.exponentialRampToValueAtTime(880, now + 0.1); g.gain.setValueAtTime(0.5, now); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.1); break; case 'complete': o.type = 'sawtooth'; o.frequency.setValueAtTime(523.25, now); g.gain.setValueAtTime(0.4, now); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5); setTimeout(() => this.playTone(659.25, 0.5), 100); setTimeout(() => this.playTone(783.99, 0.5), 200); break; case 'click': o.type = 'sine'; o.frequency.setValueAtTime(600, now); g.gain.setValueAtTime(0.5, now); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.05); break; case 'error': o.type = 'sawtooth'; o.frequency.setValueAtTime(160, now); o.frequency.exponentialRampToValueAtTime(80, now + 0.2); g.gain.setValueAtTime(0.5, now); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.2); break; } o.start(now); o.stop(now + 0.3); },
                playTone: function(freq, dur) { if(!this.isInitialized || !state.soundOn) return; const now = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = 'sawtooth'; o.connect(g); g.connect(this.masterGain); o.frequency.setValueAtTime(freq, now); g.gain.setValueAtTime(0.4, now); g.gain.exponentialRampToValueAtTime(0.0001, now + dur); o.start(now); o.stop(now + dur); }
            };
            
            function fnv1a(str) { let hash = 0x811c9dc5; for (let i = 0; i < str.length; i++) { hash ^= str.charCodeAt(i); hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24); } return hash >>> 0; }
            function mulberry32(seed) { return function() { let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

            function applyPalette(paletteName) { const palette = PALETTES[paletteName]; if (!palette) return; const root = document.documentElement; root.style.setProperty('--color-background-primary', palette.bg); root.style.setProperty('--color-text-passive', palette.text); root.style.setProperty('--color-accent-primary', palette.accent); root.style.setProperty('--color-accent-error', palette.error); const paletteIndex = PALETTE_ORDER.indexOf(paletteName); if (paletteIndex !== -1) state.currentPaletteIndex = paletteIndex; }
            async function requestFullscreen() { if (document.fullscreenElement) return; try { await document.documentElement.requestFullscreen(); } catch (err) {} }

            function navigateTo(viewName) {
                if (!dom.windows[viewName]) return; const oldView = dom.windows[state.currentView]; if (oldView) oldView.classList.remove('active');
                state.currentView = viewName; const newView = dom.windows[viewName]; newView.classList.add('active');
                
                const isGameOrMenu = (viewName === 'mainMenu' || viewName === 'game' || viewName === 'terminal' || viewName === 'stats');
                dom.settingsButton.style.display = isGameOrMenu ? 'flex' : 'none';
                if (!isGameOrMenu) { dom.settingsPanel.style.display = 'none'; }

                if (viewName === 'profiles') { generateProfileCards(); }
                else if (viewName === 'player') { state.operatorName = ''; updatePlayerNameDisplay(); resizeKeyboard(); } 
                else if (viewName === 'mainMenu') { dom.mainMenuPlayerName.textContent = state.operatorName; dom.mainMenuTotalPoints.textContent = state.playerData.totalPoints; dom.mainMenuTitle.textContent = `MENU NIVELES: ${state.currentMode}`; generateLevelButtons(); }
                else if (viewName === 'terminal') { populateTerminal(); }
                else if (viewName === 'stats') { populateStatsScreen(); }
                else if (viewName === 'validation') {
                    state.validationAttempt = '';
                    dom.validationOutput.textContent = '';
                    generateValidationKeyboard(game.currentConfig.command);
                } else if (viewName === 'game') {
                    dom.gameHud.totalPoints.textContent = `TOTAL: ${state.playerData.totalPoints}`;
                }
            }
            
            function populateTerminal() {
                dom.terminalTotalPoints.textContent = state.playerData.totalPoints;
                const container = dom.shopItemsContainer;
                container.innerHTML = '';

                for (const id in SHOP_ITEMS) {
                    const item = SHOP_ITEMS[id];
                    const currentAmount = state.playerData.inventory[id] || 0;
                    
                    const itemEl = document.createElement('div');
                    itemEl.className = 'shop-item';
                    
                    const canAfford = state.playerData.totalPoints >= item.cost;

                    itemEl.innerHTML = `
                        <h3>${item.name} [${currentAmount}]</h3>
                        <p class="shop-item-details">${item.desc}</p>
                        <div class="shop-item-footer">
                            <span class="shop-item-cost">${item.cost} P</span>
                            <button class="big-button buy-btn ${canAfford ? '' : 'disabled'}" data-item-id="${id}">COMPRAR</button>
                        </div>
                    `;
                    container.appendChild(itemEl);
                }
            }

            function populateStatsScreen() {
                const { stats, achievements } = state.playerData;
                const statsContainer = dom.statsDisplay;
                const achievementsContainer = dom.achievementsGrid;
                
                const timePlayed = stats.timePlayed || 0;
                const minutes = Math.floor(timePlayed / 60000);
                const seconds = Math.floor((timePlayed % 60000) / 1000).toString().padStart(2, '0');

                statsContainer.innerHTML = `
                    <div class="stat-card">TIEMPO DE JUEGO<div class="value">${minutes}:${seconds}</div></div>
                    <div class="stat-card">PUNTOS TOTALES<div class="value">${state.playerData.totalPoints}</div></div>
                    <div class="stat-card">NIVELES LABERINTO<div class="value">${stats.levelsCompleted_MAZE || 0} / 12</div></div>
                    <div class="stat-card">NIVELES CAMPO ABIERTO<div class="value">${stats.levelsCompleted_OPEN_FIELD || 0} / 12</div></div>
                `;

                achievementsContainer.innerHTML = '';
                for (const id in ACHIEVEMENT_DATA) {
                    const ach = ACHIEVEMENT_DATA[id];
                    const isUnlocked = achievements[id];
                    const card = document.createElement('div');
                    card.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;
                    card.innerHTML = `<h3>${ach.name}</h3><p>${ach.desc}</p>`;
                    achievementsContainer.appendChild(card);
                }
            }

            function generateValidationKeyboard(command) {
                const container = dom.validationKeyboardContainer;
                container.innerHTML = '';
                const prng = mulberry32(fnv1a(`${state.operatorName}|validation|${state.currentMode}|${state.currentLevel}`));
                
                let chars = command.split('');
                for (let i = chars.length - 1; i > 0; i--) {
                    const j = Math.floor(prng() * (i + 1));
                    [chars[i], chars[j]] = [chars[j], chars[i]];
                }

                chars.forEach(char => {
                    const key = document.createElement('button');
                    key.classList.add('validation-key');
                    key.textContent = char;
                    key.dataset.key = char;
                    container.appendChild(key);
                });

                const backspace = document.createElement('button');
                backspace.classList.add('validation-key', 'funckey');
                backspace.textContent = '<-';
                backspace.dataset.key = 'backspace';
                container.appendChild(backspace);
            }

            function resetDpadPosition() {
                dom.dpadContainer.removeAttribute('style');
            }

            function resizeKeyboard() { const GAP_SIZE = 8; const container = dom.keyboardWrapper; const keySizeFromWidth = (container.clientWidth - (7 * GAP_SIZE)) / 8; const keySizeFromHeight = (container.clientHeight - (3 * GAP_SIZE)) / 4; const finalKeySize = Math.floor(Math.min(keySizeFromWidth, keySizeFromHeight)); dom.virtualKeyboard.style.setProperty('--k', `${finalKeySize}px`); dom.virtualKeyboard.style.setProperty('--gap', `${GAP_SIZE}px`); }
            
            const keyboardLayout = [
                ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', '<-'],
                ['A', 'S', 'D', 'F', 'G', 'H', {key: 'ENTER', span: 2}],
                ['I', 'J', 'K', 'L', 'M', 'Ñ', 'O', 'P'],
                [{key: 'SHIFT', span: 2}, 'Z', 'X', 'C', 'V', 'B', 'N']
            ];

            function createVirtualKeyboard() { dom.virtualKeyboard.innerHTML = ''; keyboardLayout.flat().forEach(kI => { const kE = document.createElement('button'); kE.classList.add('key'); const k = (typeof kI === 'object') ? kI.key : kI; kE.textContent = k; kE.dataset.key = k; kE.id = `key-${k.toLowerCase()}`; if (typeof kI === 'object' && kI.span) { kE.classList.add(`span${kI.span}`); } if (['<-', 'ENTER', 'SHIFT'].includes(k)) { kE.classList.add('funckey'); } dom.virtualKeyboard.appendChild(kE); }); }
            
            function handleKeyPress(key) {
                if (key === 'ENTER') {
                    if (state.operatorName.length > 0) { storage.saveProfile(state.operatorName); state.playerData = storage.loadPlayerData(state.operatorName); navigateTo('modeSelect'); }
                } else if (key === 'SHIFT') {
                    state.isShiftActive = !state.isShiftActive;
                    document.getElementById('key-shift').classList.toggle('active', state.isShiftActive);
                } else if (key === '<-') {
                    state.operatorName = state.operatorName.slice(0, -1);
                } else if (state.operatorName.length < 20) {
                    const char = state.isShiftActive ? key.toUpperCase() : key.toLowerCase();
                    state.operatorName += char;
                }
                if (key !== 'SHIFT' && state.isShiftActive) {
                    state.isShiftActive = false;
                    document.getElementById('key-shift').classList.remove('active');
                }
                updatePlayerNameDisplay();
            }

            function updatePlayerNameDisplay() { dom.playerNameOutput.textContent = state.operatorName; }
            
            function generateProfileCards() {
                dom.profileGrid.innerHTML = '';
                const profiles = storage.loadProfiles();
                profiles.forEach(name => {
                    const card = document.createElement('button');
                    card.classList.add('profile-card');
                    card.dataset.name = name;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = name;
                    card.appendChild(nameSpan);
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-profile-btn');
                    deleteBtn.textContent = 'X';
                    deleteBtn.dataset.name = name;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        storage.deleteProfile(name);
                        generateProfileCards();
                    });
                    card.appendChild(deleteBtn);

                    dom.profileGrid.appendChild(card);
                });
            }
            
            function generateLevelButtons() {
                dom.levelGrid.innerHTML = '';
                const levels = LEVEL_CONFIG[state.currentMode];
                if (!levels) return;

                const lockSVG = `<svg class="lock-icon" viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"></path></svg>`;
                levels.forEach(levelData => {
                    const btn = document.createElement('button');
                    btn.classList.add('level-button');
                    if (storage.isLevelDone(state.currentMode, levelData.level, state.operatorName)) {
                        btn.classList.add('completed');
                        btn.innerHTML = lockSVG;
                    } else {
                        btn.textContent = levelData.level.toString().padStart(2, '0');
                        btn.dataset.level = levelData.level;
                    }
                    
                    const highscoreSpan = document.createElement('span');
                    highscoreSpan.className = 'highscore';
                    const highscore = storage.getHighscore(state.currentMode, levelData.level, state.operatorName);
                    if (highscore > 0) {
                        highscoreSpan.textContent = `HS: ${highscore}`;
                    }
                    btn.appendChild(highscoreSpan);

                    dom.levelGrid.appendChild(btn);
                });
            }

            const game = {
                ctx: null, WALL: 1, FLOOR: 0, board: {}, player: {}, state: {}, letters: [], enemies: [], keys: {ArrowUp:false,ArrowDown:false,ArrowLeft:false,ArrowRight:false}, isInitialized: false, grid: [], prng: null, currentConfig: {},
                letterCache: {}, specialBlocks: [], levelInventory: {}, particles: [],
                trail: [], lastUpdateTime: 0, isShaking: false, shakeStartTime: 0,
                
                init: function() { if (this.isInitialized) return; this.ctx = dom.gameCanvas.getContext('2d'); new ResizeObserver(() => { if(state.currentView === 'game') this.resizeCanvas(); }).observe(dom.gameCanvasWrapper); this.isInitialized = true; },
                
                shuffleArray: function(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(this.prng() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                },

                createLetterImage: function(char, color) {
                    const font_family = getComputedStyle(document.body).getPropertyValue('--font-family');
                    const svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><text x="50%" y="50%" font-size="95" font-family="${font_family}" font-weight="bold" fill="${color}" text-anchor="middle" dominant-baseline="central">${char}</text></svg>`;
                    const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                    const url = URL.createObjectURL(blob);
                    const image = new Image();
                    const promise = new Promise((resolve) => { image.onload = () => { URL.revokeObjectURL(url); resolve(image); }; image.onerror = () => { resolve(null); }; });
                    image.src = url;
                    return promise;
                },
                
                preloadLevelAssets: async function() { this.letterCache = {}; const commandChars = [...new Set(this.currentConfig.command)]; const colors = ['yellow', getComputedStyle(document.body).getPropertyValue('--color-accent-bios')]; const promises = []; for(const char of commandChars) { for(const color of colors) { const key = `${char}_${color}`; promises.push(this.createLetterImage(char, color).then(img => { this.letterCache[key] = img; })); } } await Promise.all(promises); },
                
                start: async function(levelNumber) {
                    const level = LEVEL_CONFIG[state.currentMode]?.find(l => l.level === levelNumber);
                    if (!level) return;
                    this.currentConfig = { ...level };
                    
                    this.levelInventory = JSON.parse(JSON.stringify(state.playerData.inventory));
                    this.updateInventoryHud();
                    
                    const seed = fnv1a(`${state.operatorName}|${state.currentMode}|${levelNumber}`);
                    this.prng = mulberry32(seed);
                    
                    const commandOptions = WORD_BANK[this.currentConfig.commandCategory];
                    const randomIndex = Math.floor(this.prng() * commandOptions.length);
                    this.currentConfig.command = commandOptions[randomIndex];
                    
                    state.currentLevel = levelNumber;
                    
                    navigateTo('game');
                    await this.preloadLevelAssets();
                    
                    requestAnimationFrame(() => { this.resizeCanvas(); this.reset(); });
                },

                reset: function() {
                    this.state = { score: 0, collectedCount: 0, bypassFlash: null };
                    this.trail = [];
                    this.particles = [];
                    this.setupLevel();
                },
                
                resetPlayerPosition: function(startCol, startRow, isInitialSetup = false) {
                    const gridSize = this.currentConfig.gridSize;
                    this.player = {
                        ...(this.player || {}),
                        col: startCol, row: startRow,
                        targetCol: startCol, targetRow: startRow,
                        animX: startCol * gridSize, animY: startRow * gridSize,
                        isMoving: false, animProgress: 0, moveDuration: 120,
                        teleportCooldown: 0, speedBoostEndTime: 0, wasHit: false,
                        isInvincible: true, invincibilityTimer: 90 // ~1.5 seconds at 60fps
                    };
                    if (isInitialSetup) {
                        this.player.initialCol = startCol;
                        this.player.initialRow = startRow;
                    }
                    this.displaceEnemiesFrom(startCol, startRow);
                    this.trail = [];
                },

                displaceEnemiesFrom: function(col, row) {
                    const gridSize = this.currentConfig.gridSize;
                    this.enemies.forEach(enemy => {
                        if (enemy.col === col && enemy.row === row) {
                            for (let ring = 1; ring < 10; ring++) {
                                const foundSpot = this.findEmptySpotInRing(col, row, ring);
                                if (foundSpot) {
                                    enemy.col = foundSpot.col;
                                    enemy.row = foundSpot.row;
                                    enemy.animX = foundSpot.col * gridSize;
                                    enemy.animY = foundSpot.row * gridSize;
                                    if (enemy.type === 'PATRULLA') {
                                        enemy.params.startX = enemy.col;
                                        enemy.params.startY = enemy.row;
                                        enemy.params.endX = enemy.col;
                                        enemy.params.endY = enemy.row;
                                    }
                                    return;
                                }
                            }
                        }
                    });
                },
                
                findEmptySpotInRing: function(cx, cy, r) {
                    const checks = [];
                    for (let i = -r; i <= r; i++) {
                        checks.push({col: cx + i, row: cy - r});
                        checks.push({col: cx + i, row: cy + r});
                        checks.push({col: cx - r, row: cy + i});
                        checks.push({col: cx + r, row: cy + i});
                    }
                    this.shuffleArray(checks);
                    for (const pos of checks) {
                        const isOutOfBounds = pos.row < 0 || pos.row >= this.board.rows || pos.col < 0 || pos.col >= this.board.cols;
                        if (isOutOfBounds) continue;
                        const isWall = this.grid.length > 0 && this.grid[pos.row] && this.grid[pos.row][pos.col] !== this.FLOOR;
                        if (!isWall) return pos;
                    }
                    return null;
                },

                initializeEnemies: function(availableCells) {
                    this.enemies = [];
                    if (!this.currentConfig.enemies) return;
                    const gridSize = this.currentConfig.gridSize;

                    this.currentConfig.enemies.forEach(enemyConfig => {
                        const count = enemyConfig.count || 1;
                        for (let i = 0; i < count; i++) {
                            if (availableCells.length === 0) { console.error("Not enough cells for enemies"); break; }
                            const pos = availableCells.pop();
                            
                            let patrolParams = {...enemyConfig.params};
                            if (enemyConfig.type === 'PATRULLA') {
                                patrolParams.startX = pos.col;
                                patrolParams.startY = pos.row;
                                const patrolLength = 5 + Math.floor(this.prng() * 5);
                                if (this.prng() > 0.5) {
                                    patrolParams.endX = Math.max(0, Math.min(this.board.cols - 1, pos.col + (this.prng() > 0.5 ? patrolLength : -patrolLength)));
                                    patrolParams.endY = pos.row;
                                } else {
                                    patrolParams.endX = pos.col;
                                    patrolParams.endY = Math.max(0, Math.min(this.board.rows - 1, pos.row + (this.prng() > 0.5 ? patrolLength : -patrolLength)));
                                }
                            }

                            this.enemies.push({
                                type: enemyConfig.type,
                                params: patrolParams,
                                col: pos.col, row: pos.row,
                                animX: pos.col * gridSize, animY: pos.row * gridSize,
                                direction: 1, lastMoveTime: 0
                            });
                        }
                    });
                },

                placeSpecialBlocks: function(availableCells) {
                    this.specialBlocks = [];
                    if (!this.currentConfig.specialBlocks) return;
                    
                    this.currentConfig.specialBlocks.forEach(blockConfig => {
                        const count = blockConfig.count || 1;
                        const tportPairs = {};

                        for (let i = 0; i < count; i++) {
                            if (availableCells.length === 0) { console.error("Not enough cells for special blocks"); break; }
                            const pos = availableCells.pop();
                            const newBlock = { type: blockConfig.type, col: pos.col, row: pos.row };
                            
                            if (blockConfig.type === 'T-PORT') {
                                newBlock.color = blockConfig.color;
                                const baseId = blockConfig.id * 100;
                                newBlock.id = baseId + i;
                                tportPairs[newBlock.id] = newBlock;
                            }
                            this.specialBlocks.push(newBlock);
                        }
                        
                        Object.values(tportPairs).forEach((tport, index, arr) => {
                             tport.targetId = arr[(index + 1) % arr.length].id;
                        });
                    });
                },

                placeLetters: function(availableCells) {
                    this.letters = [];
                    const command = this.currentConfig.command;
                    for (let i = 0; i < command.length; i++) {
                        if (availableCells.length === 0) { console.error("Not enough cells for letters"); break; }
                        const pos = availableCells.pop();
                        this.letters.push({ char: command[i], col: pos.col, row: pos.row, collected: false });
                    }
                },
                
                setupLevel: function() {
                    let availableCells = [];
                    if (state.currentMode === 'MAZE') {
                        this.grid = Array.from({ length: this.board.rows }, () => Array(this.board.cols).fill(this.WALL));
                        const carve = (x, y) => { this.grid[y][x] = this.FLOOR; const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]; dirs.sort(() => this.prng() - 0.5); for (let [dx, dy] of dirs) { const nx = x + dx * 2, ny = y + dy * 2; if (ny > 0 && ny < this.board.rows - 1 && nx > 0 && nx < this.board.cols - 1 && this.grid[ny][nx] === this.WALL) { this.grid[y + dy][x + dx] = this.FLOOR; carve(nx, ny); } } };
                        carve(1, 1);
                        
                        for (let r = 0; r < this.board.rows; r++) { for (let c = 0; c < this.board.cols; c++) { if (this.grid[r][c] === this.FLOOR) { availableCells.push({ col: c, row: r }); } } }
                    } else {
                        this.grid = [];
                        for (let r = 0; r < this.board.rows; r++) { for (let c = 0; c < this.board.cols; c++) { availableCells.push({ col: c, row: r }); } }
                    }

                    this.shuffleArray(availableCells);

                    if (availableCells.length === 0) { console.error("FATAL: No available cells to place objects."); return; }
                    const playerStartPos = availableCells.pop();
                    this.resetPlayerPosition(playerStartPos.col, playerStartPos.row, true);

                    this.placeSpecialBlocks(availableCells);
                    this.initializeEnemies(availableCells);
                    this.placeLetters(availableCells);
                },

                resizeCanvas: function() { const w = dom.gameCanvasWrapper; if (w.clientWidth === 0) return; const gridSize = this.currentConfig.gridSize; const mW = w.clientWidth - 20; const mH = w.clientHeight - 20; const c = Math.floor(mW / gridSize); const r = Math.floor(mH / gridSize); this.board.cols = (state.currentMode === 'MAZE' && c % 2 === 0) ? c - 1 : c; this.board.rows = (state.currentMode === 'MAZE' && r % 2 === 0) ? r - 1 : r; dom.gameCanvas.width = this.board.cols * gridSize; dom.gameCanvas.height = this.board.rows * gridSize; },
                
                update: function(timestamp) {
                    if (!this.lastUpdateTime) this.lastUpdateTime = timestamp;
                    const timeDelta = timestamp - this.lastUpdateTime;
                    if (timeDelta > 0 && timeDelta < 1000) { 
                        statsManager.logEvent('GAME_TICK', { time: timeDelta });
                    }
                    this.updatePlayer(timestamp);
                    this.updateEnemies(timestamp);
                    this.updateParticles();
                    this.checkEnemyCollisions(timestamp);
                    this.lastUpdateTime = timestamp;
                },
                updatePlayer: function(timestamp) {
                    if (this.player.isInvincible) {
                        this.player.invincibilityTimer--;
                        if (this.player.invincibilityTimer <= 0) {
                            this.player.isInvincible = false;
                        }
                    }
                    if (this.state.bypassFlash && this.state.bypassFlash.life > 0) {
                        this.state.bypassFlash.life--;
                    }
                    this.trail.forEach(p => p.life -= 0.05); this.trail = this.trail.filter(p => p.life > 0);
                    
                    const moveDuration = (timestamp < this.player.speedBoostEndTime) ? this.player.moveDuration * 0.5 : 120;

                    if (this.player.isMoving) {
                        this.player.animProgress += timestamp - this.lastUpdateTime;
                        const t = Math.min(this.player.animProgress / moveDuration, 1);
                        const gridSize = this.currentConfig.gridSize;
                        const startX = this.player.col * gridSize; const startY = this.player.row * gridSize;
                        const endX = this.player.targetCol * gridSize; const endY = this.player.targetRow * gridSize;
                        this.player.animX = startX + (endX - startX) * t; this.player.animY = startY + (endY - startY) * t;
                        if (t >= 1) { this.player.isMoving = false; this.player.col = this.player.targetCol; this.player.row = this.player.targetRow; this.checkSpecialBlocks(timestamp); this.checkCollisions(timestamp); }
                    } else {
                        let moved = false; const { col, row } = this.player; let targetCol = col, targetRow = row;
                        if (this.keys.ArrowUp) { targetRow--; moved = true; } else if (this.keys.ArrowDown) { targetRow++; moved = true; } else if (this.keys.ArrowLeft) { targetCol--; moved = true; } else if (this.keys.ArrowRight) { targetCol++; moved = true; }
                        
                        const isOutOfBounds = targetRow < 0 || targetRow >= this.board.rows || targetCol < 0 || targetCol >= this.board.cols;
                        const isWall = !isOutOfBounds && this.grid.length > 0 && this.grid[targetRow] && this.grid[targetRow][targetCol] !== this.FLOOR;
                        const isSolidBlock = !isOutOfBounds && this.specialBlocks.some(b => b.type === 'SOLID' && b.col === targetCol && b.row === targetRow);

                        if (moved && (isOutOfBounds || isWall || isSolidBlock)) {
                            if (!this.isShaking) { audioManager.playSound('error'); this.isShaking = true; this.shakeStartTime = timestamp; }
                            moved = false;
                        }
                        if (moved) { this.trail.push({ x: this.player.col * this.currentConfig.gridSize, y: this.player.row * this.currentConfig.gridSize, life: 1.0 }); this.player.isMoving = true; this.player.animProgress = 0; this.player.targetCol = targetCol; this.player.targetRow = targetRow; audioManager.playSound('move'); }
                    }
                },
                updateEnemies: function(timestamp) {
                    const gridSize = this.currentConfig.gridSize;
                    this.enemies.forEach(e => {
                        if (e.type === 'PATRULLA') {
                            const { startX, startY, endX, endY, speed } = e.params;
                            const t = (Math.sin(timestamp * speed * 0.1) + 1) / 2;
                            e.animX = (startX + (endX - startX) * t) * gridSize;
                            e.animY = (startY + (endY - startY) * t) * gridSize;
                            e.col = Math.round(e.animX / gridSize); e.row = Math.round(e.animY / gridSize);
                        } else if (e.type === 'RASTREADOR') {
                            if (timestamp > e.lastMoveTime + e.params.speed) {
                                const dx = this.player.col - e.col;
                                const dy = this.player.row - e.row;
                                let nextCol = e.col, nextRow = e.row;
                                if (Math.abs(dx) > Math.abs(dy)) {
                                    nextCol += Math.sign(dx);
                                } else if (dy !== 0) {
                                    nextRow += Math.sign(dy);
                                }
                                
                                const isWall = this.grid.length > 0 && this.grid[nextRow] && this.grid[nextRow][nextCol] !== this.FLOOR;
                                if (!isWall) { e.col = nextCol; e.row = nextRow; }
                                
                                e.animX = e.col * gridSize; e.animY = e.row * gridSize;
                                e.lastMoveTime = timestamp;
                            }
                        }
                    });
                },
                checkEnemyCollisions: function(timestamp) {
                    if (this.player.isInvincible) return;

                    const gridSize = this.currentConfig.gridSize;
                    this.enemies.forEach(e => {
                        const playerBox = {x: this.player.animX, y: this.player.animY, size: gridSize * 0.8};
                        const enemyBox = {x: e.animX, y: e.animY, size: gridSize * 0.8};

                        if (playerBox.x < enemyBox.x + enemyBox.size && playerBox.x + playerBox.size > enemyBox.x &&
                            playerBox.y < enemyBox.y + enemyBox.size && playerBox.y + playerBox.size > enemyBox.y) {
                            if (this.levelInventory.shield > 0) {
                                this.useItem('shield');
                                return;
                            }
                            this.player.wasHit = true;
                            audioManager.playSound('error');
                            this.isShaking = true; this.shakeStartTime = timestamp;
                            this.state.score = Math.max(0, this.state.score - 50);
                            
                            this.resetPlayerPosition(this.player.initialCol, this.player.initialRow); 
                        }
                    });
                },
                checkSpecialBlocks: function(timestamp) {
                    if (timestamp < this.player.teleportCooldown) return;
                    
                    const onSlowBlock = this.specialBlocks.some(b => b.type === 'SLOW' && b.col === this.player.col && b.row === this.player.row);
                    this.player.moveDuration = onSlowBlock ? 240 : 120;

                    const currentTeleporter = this.specialBlocks.find(b => b.type === 'T-PORT' && b.col === this.player.col && b.row === this.player.row);
                    if (currentTeleporter) {
                        const destinationTeleporter = this.specialBlocks.find(b => b.type === 'T-PORT' && b.id === currentTeleporter.targetId);
                        if (destinationTeleporter) {
                            this.player.col = destinationTeleporter.col; this.player.row = destinationTeleporter.row;
                            this.player.targetCol = destinationTeleporter.col; this.player.targetRow = destinationTeleporter.row;
                            const gridSize = this.currentConfig.gridSize;
                            this.player.animX = this.player.col * gridSize; this.player.animY = this.player.row * gridSize;
                            this.player.teleportCooldown = timestamp + 500;
                            audioManager.playSound('complete');
                            this.trail = [];
                        }
                    }
                },
                checkCollisions: function(timestamp) { const req = this.currentConfig.command[this.state.collectedCount]; if (!req) return; const target = this.letters.find(l => !l.collected && l.char === req && this.player.col === l.col && this.player.row === l.row); if (target) { audioManager.playSound('collect'); target.collected = true; this.state.collectedCount++; this.state.score += 100; if (this.state.collectedCount === this.currentConfig.command.length) { this.state.score += 1000; this.finalizeInventory(); navigateTo('validation'); } } else { const wrongLetter = this.letters.find(l => !l.collected && this.player.col === l.col && this.player.row === l.row); if (wrongLetter) { audioManager.playSound('error'); this.isShaking = true; this.shakeStartTime = timestamp; } } },
                updateInventoryHud: function() {
                    dom.gameHud.inventory.innerHTML = '';
                    for(const id in this.levelInventory) {
                        if (this.levelInventory[id] > 0) {
                            const item = SHOP_ITEMS[id];
                            const itemEl = document.createElement('div');
                            itemEl.className = 'inventory-item';
                            itemEl.innerHTML = `<span class="key-hint">${item.keyHint}</span> ${this.levelInventory[id]}`;
                            dom.gameHud.inventory.appendChild(itemEl);
                        }
                    }
                },
                useItem: function(itemId) {
                    if (this.levelInventory[itemId] > 0) {
                        this.levelInventory[itemId]--;
                        if (itemId === 'speed') {
                            this.player.speedBoostEndTime = this.lastUpdateTime + 5000;
                        } else if (itemId === 'bypass') {
                            const nextLetterIndex = this.state.collectedCount;
                            const targetChar = this.currentConfig.command[nextLetterIndex];
                            const nextLetter = this.letters.find(l => !l.collected && l.char === targetChar);
                            if (nextLetter) {
                                const gridSize = this.currentConfig.gridSize;
                                const x = (nextLetter.col + 0.5) * gridSize;
                                const y = (nextLetter.row + 0.5) * gridSize;
                                this.createEffect(x, y, getComputedStyle(document.body).getPropertyValue('--color-accent-bios'), 20);
                                
                                this.state.bypassFlash = { index: nextLetterIndex, life: 20 };
                                nextLetter.collected = true;
                                this.state.collectedCount++;
                                if (this.state.collectedCount === this.currentConfig.command.length) {
                                    this.state.score += 1000; this.finalizeInventory(); navigateTo('validation');
                                }
                            }
                        }
                        this.updateInventoryHud();
                        return true;
                    }
                    return false;
                },
                finalizeInventory: function() {
                    state.playerData.inventory = { ...this.levelInventory };
                    storage.savePlayerData(state.operatorName, state.playerData);
                },
                
                createEffect: function(x, y, color, count) {
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 1 + Math.random() * 3;
                        this.particles.push({
                            x: x, y: y,
                            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                            life: 20 + Math.random() * 20,
                            color: color,
                            size: 1 + Math.random() * 2
                        });
                    }
                },

                updateParticles: function() {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const p = this.particles[i];
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life--;
                        if (p.life <= 0) {
                            this.particles.splice(i, 1);
                        }
                    }
                },

                draw: function(timestamp) {
                    if (!this.currentConfig || !this.currentConfig.gridSize || this.player.animX === undefined) return;
                    this.ctx.save();
                    if (this.isShaking) { const elapsed = timestamp - this.shakeStartTime; if (elapsed > 300) { this.isShaking = false; dom.body.classList.remove('is-shaking'); } else { dom.body.classList.add('is-shaking'); } } else { dom.body.classList.remove('is-shaking'); }
                    const gridSize = this.currentConfig.gridSize;
                    this.ctx.clearRect(0, 0, dom.gameCanvas.width, dom.gameCanvas.height);
                    this.drawGrid();
                    if (state.currentMode === 'MAZE') { this.drawMaze(); }
                    this.drawSpecialBlocks();
                    this.drawParticles();
                    const trailColor = getComputedStyle(document.body).getPropertyValue('--color-accent-primary'); this.trail.forEach(p => { this.ctx.globalAlpha = p.life * 0.5; this.ctx.fillStyle = trailColor; this.ctx.fillRect(p.x, p.y, gridSize, gridSize); }); this.ctx.globalAlpha = 1;
                    const requiredChar = this.currentConfig.command[this.state.collectedCount];
                    this.letters.forEach(l => { if (!l.collected) { const color = (l.char === requiredChar) ? 'yellow' : getComputedStyle(document.body).getPropertyValue('--color-accent-bios'); const key = `${l.char}_${color}`; const letterImg = this.letterCache[key]; if (letterImg && letterImg.complete) { this.ctx.drawImage(letterImg, l.col * gridSize, l.row * gridSize, gridSize, gridSize); } } });
                    this.drawEnemies();

                    if (!(this.player.isInvincible && Math.floor(timestamp / 100) % 2 !== 0)) {
                        this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-accent-primary');
                        this.ctx.shadowColor = getComputedStyle(document.body).getPropertyValue('--color-accent-primary');
                        this.ctx.shadowBlur = 10;
                        this.ctx.fillRect(this.player.animX, this.player.animY, gridSize, gridSize);
                    }

                    if (timestamp < this.player.speedBoostEndTime) { this.ctx.strokeStyle = '#FFFF00'; this.ctx.lineWidth = 3; this.ctx.strokeRect(this.player.animX, this.player.animY, gridSize, gridSize); }
                    if (this.levelInventory.shield > 0) { this.ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--color-accent-bios'); this.ctx.lineWidth = 3; this.ctx.strokeRect(this.player.animX-3, this.player.animY-3, gridSize+6, gridSize+6); }
                    this.ctx.restore();
                    
                    let targetHTML = ''; 
                    for (let i = 0; i < this.currentConfig.command.length; i++) { 
                        const char = this.currentConfig.command[i];
                        let className = '';
                        if (i < this.state.collectedCount) { 
                            className = 'collected'; 
                        }
                        if (this.state.bypassFlash && this.state.bypassFlash.life > 0 && i === this.state.bypassFlash.index) {
                            className = 'bypass-flash';
                        }
                        targetHTML += `<span class="${className}">${char}</span>`; 
                    }
                    dom.gameHud.target.innerHTML = `TARGET: ${targetHTML}`; 
                    dom.gameHud.score.textContent = `SCORE: ${this.state.score}`;
                },
                gameLoop: function(timestamp) { 
                    if (dom.fullscreenEnforcer.classList.contains('active')) {
                        this.lastUpdateTime = 0;
                    } else if (state.currentView === 'game') { 
                        this.update(timestamp); this.draw(timestamp); 
                    }
                    requestAnimationFrame(this.gameLoop.bind(this));
                },
                drawGrid: function() { const gridSize = this.currentConfig.gridSize; this.ctx.save(); this.ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--color-funckey-primary'); this.ctx.globalAlpha = 0.5; this.ctx.lineWidth = 1; for (let i = 1; i < this.board.cols; i++) { const x = i * gridSize; this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, dom.gameCanvas.height); this.ctx.stroke(); } for (let i = 1; i < this.board.rows; i++) { const y = i * gridSize; this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(dom.gameCanvas.width, y); this.ctx.stroke(); } this.ctx.restore(); },
                drawMaze: function() { const gridSize = this.currentConfig.gridSize; this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-funckey-primary'); for (let r = 0; r < this.board.rows; r++) { for (let c = 0; c < this.board.cols; c++) { if (this.grid[r] && this.grid[r][c] === this.WALL) { this.ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize); } } } },
                drawSpecialBlocks: function() {
                    const gridSize = this.currentConfig.gridSize;
                    this.specialBlocks.forEach(b => {
                        const x = b.col * gridSize; const y = b.row * gridSize;
                        if (b.type === 'SOLID') { this.ctx.fillStyle = '#404040'; this.ctx.fillRect(x, y, gridSize, gridSize); this.ctx.strokeStyle = '#606060'; this.ctx.strokeRect(x,y,gridSize,gridSize); } 
                        else if (b.type === 'SLOW') { this.ctx.fillStyle = 'rgba(0, 100, 255, 0.4)'; this.ctx.fillRect(x, y, gridSize, gridSize); }
                        else if (b.type === 'T-PORT') { this.ctx.fillStyle = b.color || '#A43BFF'; this.ctx.fillRect(x + gridSize * 0.1, y + gridSize * 0.1, gridSize * 0.8, gridSize * 0.8); }
                    });
                },
                drawEnemies: function() {
                    const gridSize = this.currentConfig.gridSize;
                    this.enemies.forEach(e => {
                        if (e.type === 'PATRULLA') { this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-accent-error'); }
                        else if (e.type === 'RASTREADOR') { this.ctx.fillStyle = '#FF8C00'; } // DarkOrange
                        this.ctx.fillRect(e.animX, e.animY, gridSize, gridSize);
                    });
                },
                drawParticles: function() {
                    this.particles.forEach(p => {
                        this.ctx.globalAlpha = p.life / 40;
                        this.ctx.fillStyle = p.color;
                        this.ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                    });
                    this.ctx.globalAlpha = 1;
                }
            };

            function runPreflightChecks() {
                return new Promise((resolve, reject) => {
                    const requiredWindows = ['preload', 'title', 'profiles', 'modeSelect', 'player', 'mainMenu', 'terminal', 'stats', 'game', 'validation', 'victory'];
                    for (const id of requiredWindows) {
                        if (!document.getElementById(id)) {
                            reject(new Error(`[PREFLIGHT][ERR] Missing critical window: #${id}`));
                            return;
                        }
                    }
                    resolve('[PREFLIGHT][OK] All systems nominal.');
                });
            }

            function init() {
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    document.body.classList.add('touch-device');
                }
                applyPalette(storage.loadPalette() || 'CODIGO_CIAN');
                state.soundOn = storage.loadSoundPref();
                dom.soundBtn.textContent = `SONIDO: ${state.soundOn ? 'ON' : 'OFF'}`;
                state.dpadVisible = storage.loadDpadPref();
                dom.dpadContainer.classList.toggle('visible', state.dpadVisible);
                dom.dpadSettingsBtn.textContent = `D-PAD: ${state.dpadVisible ? 'ON' : 'OFF'}`;

                
                document.getElementById('resume-fullscreen-btn').addEventListener('click', requestFullscreen);

                document.body.addEventListener('click', (e) => {
                    const target = e.target;
                    
                    const isSettingsButton = target.closest('#settings-panel button');

                    if (target.id !== 'settings-button' && !isSettingsButton) {
                        dom.settingsPanel.style.display = 'none';
                    }

                    audioManager.init();
                    
                    if(target.id !== 'resume-fullscreen-btn' && !isSettingsButton) {
                        audioManager.playSound('click');
                    }

                    const validationKey = target.closest('.validation-key');
                    if (validationKey) {
                        const key = validationKey.dataset.key;
                        if (key === 'backspace') {
                            state.validationAttempt = state.validationAttempt.slice(0, -1);
                        } else if (state.validationAttempt.length < game.currentConfig.command.length) {
                            state.validationAttempt += key;
                        }
                        dom.validationOutput.textContent = state.validationAttempt;
                        return;
                    }

                    const buyBtn = target.closest('.buy-btn');
                    if (buyBtn) {
                        const itemId = buyBtn.dataset.itemId;
                        const item = SHOP_ITEMS[itemId];
                        if (state.playerData.totalPoints >= item.cost) {
                            state.playerData.totalPoints -= item.cost;
                            state.playerData.inventory[itemId] = (state.playerData.inventory[itemId] || 0) + 1;
                            storage.savePlayerData(state.operatorName, state.playerData);
                            statsManager.checkAchievements();
                            populateTerminal();
                        }
                        return;
                    }

                    if (state.currentView === 'preload' || target.id === 'start-btn' || target.closest('#title')) { requestFullscreen(); navigateTo('profiles'); return; }
                    
                    const keyTarget = target.closest('.key');
                    if (state.currentView === 'player' && keyTarget) { handleKeyPress(keyTarget.dataset.key); return; }
                    
                    const levelTarget = target.closest('.level-button');
                    if (levelTarget && levelTarget.dataset.level) { game.start(parseInt(levelTarget.dataset.level, 10)); return; }

                    const profileTarget = target.closest('.profile-card');
                    if (profileTarget && !target.classList.contains('delete-profile-btn')) { 
                        state.operatorName = profileTarget.dataset.name; 
                        state.playerData = storage.loadPlayerData(state.operatorName);
                        navigateTo('modeSelect'); 
                        return; 
                    }
                    
                    const modeTarget = target.closest('.mode-button');
                    if(modeTarget) {
                        state.currentMode = modeTarget.dataset.mode;
                        navigateTo('mainMenu');
                        return;
                    }
                    
                    if (target.id === 'new-player-btn') { navigateTo('player'); return; }
                    if (target.id === 'victory-continue-btn') { navigateTo('mainMenu'); return; }
                    if (target.id === 'change-mode-btn') { navigateTo('modeSelect'); return; }
                    if (target.id === 'terminal-btn') { navigateTo('terminal'); return; }
                    if (target.id === 'back-to-menu-btn') { navigateTo('mainMenu'); return; }
                    if (target.id === 'stats-btn' || target.id === 'stats-back-btn') { navigateTo(target.id === 'stats-btn' ? 'stats' : 'mainMenu'); return; }
                    
                    if (target.id === 'settings-button') { dom.settingsPanel.style.display = (dom.settingsPanel.style.display === 'block') ? 'none' : 'block'; return; }
                    
                    if (isSettingsButton) {
                        audioManager.playSound('click');
                        if (target.id === 'sound-btn') {
                            state.soundOn = !state.soundOn;
                            storage.saveSoundPref(state.soundOn);
                            target.textContent = `SONIDO: ${state.soundOn ? 'ON' : 'OFF'}`;
                        }
                        if (target.id === 'palette-btn') {
                            state.currentPaletteIndex = (state.currentPaletteIndex + 1) % PALETTE_ORDER.length;
                            const newPaletteName = PALETTE_ORDER[state.currentPaletteIndex];
                            applyPalette(newPaletteName);
                            storage.savePalette(newPaletteName);
                        }
                        if (target.id === 'dpad-settings-btn') {
                            state.dpadVisible = !state.dpadVisible;
                            storage.saveDpadPref(state.dpadVisible);
                            if (state.dpadVisible) {
                                resetDpadPosition(); 
                            }
                            dom.dpadContainer.classList.toggle('visible', state.dpadVisible);
                            target.textContent = `D-PAD: ${state.dpadVisible ? 'ON' : 'OFF'}`;
                        }
                        if (target.id === 'change-player-btn') {
                            navigateTo('profiles');
                        }
                        if (target.id === 'exit-btn') {
                            window.close();
                        }
                        dom.settingsPanel.style.display = 'none';
                        return;
                    }
                    
                    if (target.id === 'validate-word-btn') { 
                        if(state.validationAttempt.toUpperCase() === game.currentConfig.command) {
                            const wasUntouchable = game.currentConfig.enemies && game.currentConfig.enemies.length > 0 && !game.player.wasHit;
                            storage.markLevelAsDone(state.currentMode, state.currentLevel, state.operatorName); 
                            storage.setHighscore(state.currentMode, state.currentLevel, state.operatorName, game.state.score);
                            state.playerData.totalPoints += game.state.score;
                            game.finalizeInventory(); 
                            statsManager.logEvent('LEVEL_COMPLETE', { mode: state.currentMode, isUntouchable: wasUntouchable });
                            
                            audioManager.playSound('complete');
                            navigateTo('victory');
                        } else {
                            audioManager.playSound('error');
                            dom.validationOutput.classList.add('error');
                            setTimeout(() => dom.validationOutput.classList.remove('error'), 300);
                        }
                    }
                    if (target.id === 'hint-btn') { 
                        game.state.score = Math.max(0, game.state.score - 250);
                        state.validationAttempt = game.currentConfig.command;
                        dom.validationOutput.textContent = state.validationAttempt;
                    }
                });
                
                window.addEventListener('keydown', (e) => { 
                    if (state.currentView === 'player') {
                        if (e.key === 'Enter') handleKeyPress('ENTER');
                        else if (e.key === 'Backspace') handleKeyPress('<-');
                        else if (e.key.toUpperCase() === 'Ñ') handleKeyPress('Ñ');
                        else if (/^[a-zA-Z]$/.test(e.key)) handleKeyPress(e.key.toUpperCase());
                    } else if (state.currentView === 'title' && e.key === 'Enter') {
                        navigateTo('profiles'); 
                    } else if (state.currentView === 'game') {
                        if (e.key === '1') game.useItem('shield');
                        else if (e.key === '2') game.useItem('bypass');
                        else if (e.key === '3') game.useItem('speed');
                    }
                    if(e.key in game.keys) { e.preventDefault(); game.keys[e.key] = true; }
                });
                window.addEventListener('keyup', (e) => { if(e.key in game.keys) { e.preventDefault(); game.keys[e.key] = false; }});
                
                dom.dpadBtns.forEach(btn => {
                    const key = btn.dataset.key;
                    const press = (e) => { e.preventDefault(); game.keys[key] = true; };
                    const release = (e) => { e.preventDefault(); game.keys[key] = false; };
                    btn.addEventListener('touchstart', press, { passive: false });
                    btn.addEventListener('touchend', release);
                    btn.addEventListener('mousedown', press);
                    btn.addEventListener('mouseup', release);
                    btn.addEventListener('mouseleave', release);
                });
                
                document.addEventListener('fullscreenchange', () => {
                    const isGameActive = !['preload', 'title', 'profiles', 'player'].includes(state.currentView);
                    if (!document.fullscreenElement && isGameActive) {
                        dom.fullscreenEnforcer.classList.add('active');
                    } else {
                        dom.fullscreenEnforcer.classList.remove('active');
                    }
                });

                const dpad = dom.dpadContainer;
                const dragHandle = document.getElementById('dpad-drag-handle');
                let isDragging = false;
                let offsetX, offsetY;

                const startDrag = (e) => {
                    isDragging = true;
                    e.preventDefault(); 
                    const pointerX = e.pageX || e.touches[0].pageX;
                    const pointerY = e.pageY || e.touches[0].pageY;
                    offsetX = pointerX - dpad.offsetLeft;
                    offsetY = pointerY - dpad.offsetTop;
                    window.addEventListener('mousemove', onDrag, { passive: false });
                    window.addEventListener('touchmove', onDrag, { passive: false });
                    window.addEventListener('mouseup', stopDrag);
                    window.addEventListener('touchend', stopDrag);
                };

                const onDrag = (e) => {
                    if (!isDragging) return;
                    e.preventDefault(); 
                    const pointerX = e.pageX || e.touches[0].pageX;
                    const pointerY = e.pageY || e.touches[0].pageY;
                    let newLeft = pointerX - offsetX;
                    let newTop = pointerY - offsetY;
                    const maxX = window.innerWidth - dpad.offsetWidth;
                    const maxY = window.innerHeight - dpad.offsetHeight;
                    newLeft = Math.max(0, Math.min(newLeft, maxX));
                    newTop = Math.max(0, Math.min(newTop, maxY));
                    dpad.style.left = `${newLeft}px`;
                    dpad.style.top = `${newTop}px`;
                    dpad.style.bottom = 'auto';
                    dpad.style.transform = 'none';
                };

                const stopDrag = () => {
                    isDragging = false;
                    window.removeEventListener('mousemove', onDrag);
                    window.removeEventListener('touchmove', onDrag);
                    window.removeEventListener('mouseup', stopDrag);
                    window.removeEventListener('touchend', stopDrag);
                };

                dragHandle.addEventListener('mousedown', startDrag);
                dragHandle.addEventListener('touchstart', startDrag, { passive: false });

                createVirtualKeyboard(); 
                game.init();
                requestAnimationFrame(game.gameLoop.bind(game));
                
                const preflightStatus = document.getElementById('preflight-status');
                const startupChecks = runPreflightChecks();
                const startupTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('System timeout. Preflight checks failed to complete.')), 3000));

                Promise.race([startupChecks, startupTimeout])
                    .then(successMsg => {
                        preflightStatus.innerHTML = successMsg.replace('[PREFLIGHT][OK]', '<span style="color:var(--color-accent-bios)">[PREFLIGHT][OK]</span>');
                        setTimeout(() => navigateTo('title'), 1000);
                    })
                    .catch(error => {
                        const biosTextContainer = document.querySelector('#preload .bios-text');
                        preflightStatus.innerHTML = `<span style="color:var(--color-accent-error)">${error.message}</span>`;
                        const forceButton = document.createElement('button');
                        forceButton.textContent = 'FORZAR ARRANQUE';
                        forceButton.className = 'big-button';
                        forceButton.style.marginTop = '2rem';
                        forceButton.onclick = () => navigateTo('title');
                        biosTextContainer.parentElement.appendChild(forceButton);
                    });
            }
            init();
        });
    </script>
</body>
</html>
